# Visitify

# **概要**

Visitifyは、ユーザがおすすめの観光スポットをGoogle Map上にピン留めして登録、シェアすることができるアプリです。他のユーザは登録されたピン留めを確認できます。

# **システム構成**

- フロントエンド：HTML, CSS, JavaScript, Bootstrap
- バックエンド：Django
- データベース：SQlite3
- インフラ : AWS
- Webサーバ：Nginx
- Appサーバ：Gunicorn
- ストレージ：Amazon S3
- セキュリティ：SSL証明書, WAF

# **機能要件**

1. ユーザ登録機能
    1. 新規ユーザはメールアドレスとパスワードを入力してアカウントを作成できる。
2. ログイン機能
    1. 登録済みユーザはメールアドレスとパスワードでログインできる。
    2. ログインログアウトパスワード変更アカウント削除ピン留め登録機能ユーザはGoogle Map上にピン留めして、観光スポットの名前、URL、住所、写真、説明文などの情報を登録できる。
    3. ユーザーは、観光スポットの名前やURLなどの情報を入力し、地図上にピン留めすることができます。
    4. また、自分が登録した観光スポットの編集・削除もできるようにする必要があります。
3. ピン留め編集機能
    1. 登録済みユーザは、登録したピン留めの情報を編集できる。
4. ピン留め削除機能
    1. 登録済みユーザは、登録したピン留めを削除できる。
5. ピン留め表示機能
    1. ユーザはGoogle Map上に登録されたピン留めを確認できる。
    2. ピン留めをクリックすると、観光スポットの詳細情報が表示される。
6. シェア機能
    1. 登録されたピン留めを他のユーザとシェアできる。
    2. ユーザーがピン留めした観光スポットの中から、他のユーザーに特におすすめしたいものを選択できるようにする。
7. 検索機能
    1. 観光スポットの名前や地名で検索できるようにすることで、ユーザーが簡単に目的の観光スポットを見つけられるようにします。
    2. コメント機能ユーザーが観光スポットにコメントを残すことができるようにすることで、他のユーザーと情報を共有できるようにします。
8. いいね機能通知機能
9. 画像アップロード機能
10. キーワード検索機能
11. Google Maps APIの連携
    1. Google Maps APIを利用し、ピン留めした観光スポットの位置情報を地図上に表示します。
    2. また、ユーザーがピンをクリックすることで、観光スポットの詳細情報を表示する機能も必要です。

# **非機能要件**

- セキュリティ
  - ユーザの情報は、パスワードをハッシュ化して保存することで、情報漏洩を防止する。
  - システムにアクセスするための認証・認可方法や、通信の暗号化、不正アクセス対策など、セキュリティに関する対策を検討する必要があります。
- UI/UX
  - 使いやすくわかりやすいUI/UXを実現するため、適切なデザインと操作性を考慮する。
- セキュリティ性
  - ユーザ情報や観光スポット情報が漏れないように、適切なセキュリティ対策を実施する。
- パフォーマンス
  - 多くのユーザが同時にアクセスしても、快適に利用できるように、サーバのスケーラビリティを考慮する。
- 拡張性
  - 将来的な拡張や機能追加を想定して、システムの拡張性を高める。
- 可用性
  - システムの稼働時間を24時間365日確保するために、バックアップや障害時の対応策を検討する。
- アクセシビリティ
  - ユーザが利用しやすいUIを実現するために、バリアフリー対応や視覚障害者向けの機能を実装する。
- 可読性
  - コードやドキュメントが読みやすく、保守性が高いようにする。
- テスト性
  - システムの品質を保証するために、適切な単体テストや結合テストを実施する。
- ドキュメンテーション
  - システムの仕様や操作方法を明確にするために、ドキュメントを作成する。
- ログ・監視
  - システムの異常を検知し、対処するために、ログや監視機能を実装する。
  - ハードウェア・ソフトウェアの稼働状況、ネットワークトラフィック、ログファイルバックアップ システムデータのバックアップ方法を検討し、運用する必要があります。
  - バックアップ頻度や保管場所、リストア手順などを明確にすることで、データの復旧がスムーズに行えるようになります。
- デプロイメント
  - システムを本番環境に展開するための手順やスケジュールを決定し、運用する必要があります。
  - デプロイメント手順の確立やテスト環境の整備などを行うことで、リスクを最小限に抑えながらシステムを本番環境に導入することができます。

# 画面イメージ

1. ログインページ
2. 新規登録ページ
3. プロフィールページ
4. 観光スポット一覧ページ
5. 観光スポット詳細ページ
6. 観光スポット登録ページ
7. 観光スポット編集ページ
8. 観光スポット削除ページ
9. 検索結果ページ
10. コメント投稿ページ
11. 通知ページ
12. 設定ページ

- ログインページ：ログインAPI
- 新規登録ページ：ユーザー登録API
- プロフィールページ：ユーザー情報取得API
- 観光スポット一覧ページ：観光スポット一覧取得API
- 観光スポット詳細ページ：観光スポット詳細取得API、いいね投稿API、コメント投稿API
- 観光スポット登録ページ：観光スポット登録API
- 観光スポット編集ページ：観光スポット編集API
- 観光スポット削除ページ：観光スポット削除API
- 検索結果ページ：検索API、観光スポット一覧取得API
- コメント投稿ページ：コメント投稿API
- 通知ページ：通知取得API
- 設定ページ：ユーザー情報取得API、ユーザー情報更新API、画像アップロードAPI

ログインページ：

- ユーザ名とパスワードを入力するためのフォームが表示される。
- ログインボタンがあり、ボタンをクリックすると入力された情報を送信し、認証が成功すると観光スポット一覧ページにリダイレクトされる。
- 新規登録ボタンがあり、ボタンをクリックすると新規登録ページにリダイレクトされる。

新規登録ページ：

- ユーザ名、メールアドレス、パスワード、パスワード確認用のフォームが表示される。
- 登録ボタンがあり、ボタンをクリックすると入力された情報を送信し、新規ユーザが作成される。
- ログインボタンがあり、ボタンをクリックするとログインページにリダイレクトされる。

プロフィールページ：

- ユーザのプロフィール情報が表示される。
- プロフィール情報の編集ボタンがあり、ボタンをクリックするとプロフィール編集ページにリダイレクトされる。

観光スポット一覧ページ：

- 登録されている観光スポットの一覧が表示される。
- 各観光スポットの名称、画像、概要、お気に入り数などが表示される。
- 観光スポットの詳細ページにリンクされている。
- ページネーションがある場合、ページ番号や前後のページへのリンクが表示される。

観光スポット詳細ページ：

- 選択された観光スポットの詳細情報が表示される。
- 画像、名称、住所、説明、お気に入り数、コメントなどが表示される。
- ユーザがお気に入り登録、コメント投稿ができるようなフォームやボタンがある。
- 編集、削除ボタンがある（権限がある場合）。

観光スポット登録ページ：

- 観光スポットの名称、住所、概要、画像などの情報を入力するためのフォームが表示される。
- 登録ボタンがあり、ボタンをクリックすると入力された情報をデータベースに保存し、観光スポット一覧ページにリダイレクトされる。

1. 観光スポット編集ページ：このページでは、ユーザーが登録した観光スポットの情報を編集できます。フォームを用意し、現在の情報が表示され、必要な情報を編集して送信することで、データベース内の観光スポット情報が更新されます。
2. 観光スポット削除ページ：このページでは、ユーザーが登録した観光スポットの情報を削除できます。削除する観光スポットを選択し、削除確認のポップアップが表示され、確認後削除ボタンを押すことで、データベースから選択された観光スポットの情報が削除されます。
3. 検索結果ページ：このページでは、ユーザーがキーワード検索した結果を一覧で表示します。一覧には、検索キーワードに該当する観光スポットの情報が表示され、それぞれの観光スポットの詳細ページへのリンクが付いています。
4. コメント投稿ページ：このページでは、ユーザーが観光スポット詳細ページで投稿したコメントを編集できます。フォームを用意し、現在のコメント内容が表示され、必要な情報を編集して送信することで、データベース内のコメント情報が更新されます。また、コメントを削除することもできます。

通知ページ:

- ログインしているユーザーが受信した通知を一覧で表示するページ。
- 通知の種類によって、アイコンや色分けなどで区別することができる。
- 通知の内容に応じて、適切なアクションを選択するためのボタンやリンクが用意されていることがある。

設定ページ:

- ログインしているユーザーのプロフィール情報やアカウント設定を変更するためのページ。
- プロフィール画像や自己紹介文などの基本情報や、パスワード変更やメールアドレスの更新などのアカウント設定が可能。
- 退会手続きもここで行える場合がある。

# データベース構造

# 型と属性

1. Account
    1. DjangoにおけるUserモデルは、認証システムにおけるユーザーを表現するためのモデルです。**`django.contrib.auth.models`**モジュールに含まれています。
    2. Userモデルは以下のようなフィールドを持っています。
    3. **`username`**: 文字列型、最大長150文字。必須。
    4. **`password`**: 文字列型、最大長128文字。必須。
    5. **`email`**: 文字列型、最大長254文字。オプション。
    6. **`first_name`**: 文字列型、最大長30文字。オプション。
    7. **`last_name`**: 文字列型、最大長150文字。オプション。
    8. **`is_staff`**: 真偽値型。管理サイトにアクセスする権限を持つかどうかを示す。デフォルトはFalse。
    9. **`is_active`**: 真偽値型。アカウントが有効かどうかを示す。デフォルトはTrue。
    10. **`is_superuser`**: 真偽値型。全ての権限を持つスーパーユーザーかどうかを示す。デフォルトはFalse。
    11. **`last_login`**: 日時型。最終ログイン日時を示す。デフォルトはNone。
    12. **`date_joined`**: 日時型。アカウント作成日時を示す。デフォルトはtimezone.now()。

また、Userモデルは以下のようなメソッドを持っています。

- **`get_full_name()`**: ユーザーのフルネームを取得する。
- **`get_short_name()`**: ユーザーの名前を取得する。
- **`email_user(subject, message, from_email=None, **kwargs)`**: ユーザーにメールを送信する。

これらのメソッドは、カスタムUserモデルでオーバーライドすることができます。

1. spotsテーブル
    - id: 自動採番の整数型 (Primary Key)
    - name: 文字列型、最大長255文字
    - address: 文字列型、最大長255文字
    - latitude: 実数型
    - longitude: 実数型
    - user_id: 整数型 (Foreign Key, usersテーブルのidカラムを参照)
    - created_at: 日時型、デフォルトで現在日時を設定
2. categoriesテーブル
    - id: 自動採番の整数型 (Primary Key)
    - name: 文字列型、最大長255文字
3. spot_categoriesテーブル
    - id: 自動採番の整数型 (Primary Key)
    - spot_id: 整数型 (Foreign Key, spotsテーブルのidカラムを参照)
    - category_id: 整数型 (Foreign Key, categoriesテーブルのidカラムを参照)
4. commentsテーブル
    - id: 自動採番の整数型 (Primary Key)
    - content: 文字列型、最大長1000文字
    - user_id: 整数型 (Foreign Key, usersテーブルのidカラムを参照)
    - spot_id: 整数型 (Foreign Key, spotsテーブルのidカラムを参照)
    - created_at: 日時型、デフォルトで現在日時を設定
5. likesテーブル
    - id: 自動採番の整数型 (Primary Key)
    - user_id: 整数型 (Foreign Key, usersテーブルのidカラムを参照)
    - spot_id: 整数型 (Foreign Key, spotsテーブルのidカラムを参照)
6. notificationsテーブル
    - id: 自動採番の整数型 (Primary Key)
    - user_id: 整数型 (Foreign Key, usersテーブルのidカラムを参照)
    - content: 文字列型、最大長255文字
    - url: 文字列型、最大長255文字
    - read_at: 日時型、既読になった日時を設定する。未読の場合はNULL
7. imagesテーブル
    - id: 自動採番の整数型 (Primary Key)
    - filename: 文字列型、最大長255文字
    - spot_id: 整数型 (Foreign Key, spotsテーブルのidカラムを参照)

# リレーション

1. Usersテーブルは、Pins、Likes、Comments、Notificationsテーブルと1対多の関係にあります。
2. Pinsテーブルは、Users、Locations、Categories、Images、Tags、Likes、Commentsテーブルと1対多の関係にあります。
3. Locationsテーブルは、Pinsテーブルと1対多の関係にあります。
4. Categoriesテーブルは、Pinsテーブルと多対多の関係にあります。
5. Imagesテーブルは、Pinsテーブルと1対多の関係にあります。
6. Tagsテーブルは、Pinsテーブルと多対多の関係にあります。
7. Likesテーブルは、Users、Pinsテーブルと多対多の関係にあります。
8. Commentsテーブルは、Users、Pinsテーブルと1対多の関係にあります。
9. Notificationsテーブルは、Usersテーブルと1対多の関係にあります。

## より詳しく

1. UsersテーブルとPinsテーブル

- ユーザが投稿したピン留めを複数登録できるため、一対多の関係を持ちます。
- Usersテーブルのuser_idが、Pinsテーブルのuser_id(FK)に対応します。

1. PinsテーブルとImagesテーブル

- 1つのピン留めに複数の画像を登録できるため、一対多の関係を持ちます。
- Pinsテーブルのpin_idが、Imagesテーブルのpin_id(FK)に対応します。

1. PinsテーブルとLikesテーブル

- 1つのピン留めに複数のいいねが付けられるため、一対多の関係を持ちます。
- Pinsテーブルのpin_idが、Likesテーブルのpin_id(FK)に対応します。

1. UsersテーブルとLikesテーブル

- 1つのユーザが複数のいいねを付けることができるため、多対多の関係を持ちます。
- Usersテーブルのuser_idが、Likesテーブルのuser_id(FK)に対応します。

1. UsersテーブルとNotificationsテーブル

- 1つのユーザが複数の通知を受け取ることができるため、一対多の関係を持ちます。
- Usersテーブルのuser_idが、Notificationsテーブルのrecipient_id(FK)に対応します。

1. UsersテーブルとSearchHistoryテーブル

- 1つのユーザが複数の検索履歴を持つことができるため、一対多の関係を持ちます。
- Usersテーブルのuser_idが、SearchHistoryテーブルのuser_id(FK)に対応します。

1. PinsテーブルとTagsテーブル

- 1つのピン留めに複数のタグを付けることができるため、多対多の関係を持ちます。
- Pinsテーブルのpin_idが、PinTagテーブルのpin_id(FK)に対応し、Tagsテーブルのtag_idが、PinTagテーブルのtag_id(FK)に対応します。

1. UsersテーブルとFollowsテーブル

- 1つのユーザが複数

# 考慮すべき点

1. パフォーマンスの最適化: データベースが膨大なデータを扱う場合、クエリのパフォーマンスに影響を与える可能性があります。そのため、適切なインデックスを設定することで、クエリの実行速度を向上させることが重要です。
2. データの正規化: データの重複や矛盾がないように、データベース設計において正規化を行う必要があります。正規化を行うことで、データの整合性を保ち、データの更新や変更が容易になります。
3. セキュリティ: ユーザの個人情報や機密情報を扱う場合、適切なセキュリティ対策が必要です。パスワードのハッシュ化、SQLインジェクションやクロスサイトスクリプティングなどの脆弱性に対する対策が必要です。
4. 拡張性: アプリケーションの拡張に対応できるように、データベース設計において拡張性を考慮することが重要です。将来的に新しい機能やテーブルを追加することができるように、適切な設計を行う必要があります。
5. バックアップと復元: データの損失を防ぐために、適切なバックアップと復元の戦略を策定することが重要です。データのバックアップの頻度や、復元の方法を定期的に確認することで、データの安全性を確保することができます。

- データの整合性を保つために、制約やトリガーを設定する。
- データベースのパフォーマンスを向上させるために、適切なインデックスを作成する。
- データのバックアップと復旧について、適切な戦略を策定する。
- セキュリティについて適切な対策を講じる。例えば、ユーザのパスワードのハッシュ化や、SQLインジェクションやクロスサイトスクリプティングの防止など。
- 今後のシステムの拡張性を考慮して、データベースの設計に余裕を持たせる。例えば、テーブルに予め不要なカラムを追加しておいたり、不要なカラムを削除しないことで、将来的な機能追加や仕様変更に対応しやすくする。
- データベースの可用性について、適切な設計を行う。例えば、データベースの冗長化やレプリケーションの設定、クラスタリングの構築など。
